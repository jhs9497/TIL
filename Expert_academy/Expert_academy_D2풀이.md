### 1945. 간단한 소인수분해

> 숫자 N은 아래와 같다.
>
> N=2a x 3b x 5c x 7d x 11e
>
> N이 주어질 때 a, b, c, d, e 를 출력하라.
>
> 
> **[제약 사항]**
>
> N은 2 이상 10,000,000 이하이다.
>
> 
> **[입력]**
>
> 가장 첫 줄에는 테스트 케이스의 개수 T가 주어지고, 그 아래로 각 테스트 케이스가 주어진다.
>
> 각 테스트 케이스의 첫 번째 줄에 N 이 주어진다.
>
> 
> **[출력]**
>
> 출력의 각 줄은 '#t'로 시작하고, 공백을 한 칸 둔 다음 정답을 출력한다.
>
> (t는 테스트 케이스의 번호를 의미하며 1부터 시작한다.)
>
> 입력
>
> 10 
> 6791400
> 1646400
> 1425600
> 8575
> 185625
> 6480
> 1185408
> 6561
> 25
> 330750
>
> 출력
>
> #1 3 2 2 3 1
> \#2 6 1 2 3 0
> \#3 6 4 2 0 1
> \#4 0 0 2 3 0
> \#5 0 3 4 0 1
> \#6 4 4 1 0 0
> \#7 7 3 0 3 0
> \#8 0 8 0 0 0
> \#9 0 0 2 0 0
> \#10 1 3 3 2 0



#### Think Process ⚡

1. N을 a, b, c, d, e로 각각 나누어서 나누어 떨어지면 그 횟수를 count해야한다.
2. if문을 이용한다면 횟수를 count하긴 어렵다.
3. while문을 이용하자
4. 파이썬은 위에서 아래로 순서대로 이루어지므로 if elif else구문을 사용할 필요 없을 듯 하다
5. 어차피 2, 3, 5, 7, 11만 물어보고 있으니 47과 같은 서로소는 고려 X

#### 코딩 풀이 👀

```python
test_case = int(input())
# 10개의 test_case가 필요하므로 for문으로 test_case 숫자만큼 돌리며
for i in range(test_case):
    # N은 또 한번 인풋을 받는다.
    N = int(input())
    
    # 최종 출력값인 a~e를 0으로 두고
    a = 0
    b = 0
    c = 0
    d = 0
    e = 0
    # N이 2로 나눠지는 동안에는 N을 2로 나누며 한 번 나눌때마다 a에 1씩 추가한다.
    while N % 2 ==0:
        N = N / 2
        a += 1
    
    while N % 3 ==0:
        N = N / 3
        b += 1  

    while N % 5 ==0:
        N = N / 5
        c += 1

    while N % 7 ==0:
        N = N / 7
        d += 1

    # 11까지 동일한 방식으로 진행한다.
    while N % 11 ==0:
        N = N / 11
        e += 1
    # 답안마다 #n을 붙혀야하므로 f스트링으로 하고 a~e까지의 변수도 {}로 묶어준다.
    print(f'#{i+1} {a} {b} {c} {d} {e}')
```



### 1926. 간단한 369게임

> 3 6 9 게임을 프로그램으로 제작중이다. 게임 규칙은 다음과 같다.
>
>  
>
> \1. 숫자 1부터 순서대로 차례대로 말하되, **“3” “6” “9”** 가 들어가 있는 수는 말하지 않는다.
>
>  **1 2** **3** **4 5** **6** **7 8** **9…**
>
> \2. "3" "6" "9"가 들어가 있는 수를 말하지 않는대신, 박수를 친다. 이 때, 박수는 해당 숫자가 들어간 개수만큼 쳐야 한다. 
> 예를 들어 숫자 35의 경우 박수 한 번, 숫자 36의 경우 박수를 두번 쳐야 한다.
>
> 입력으로 정수 N 이 주어졌을 때, 1~N 까지의 숫자를
>
> 게임 규칙에 맞게 출력하는 프로그램을 작성하라.
>
> 박수를 치는 부분은 숫자 대신, 박수 횟수에 맞게 “-“ 를 출력한다.
>
> **여기서 주의해야 할 것은 박수 한 번 칠 때는 - 이며, 박수를 두 번 칠 때는 - - 가 아닌 -- 이다. 
> ** 
>
> **[제약사항]**
>
> N은 10이상 1,000이하의 정수이다. (10 ≤ N ≤ 1,000)
>
>  
>
> **[입력]**
>
> 입력으로 정수 N 이 주어진다.
>
> 
> **[****출력]**
>
> 1 ~ N까지의 숫자를 게임 규칙에 맞게 출력한다.
>
> 
>
> 입력10
>
> 출력1 2 - 4 5 - 7 8 - 10



#### Think Process ⚡

1. 컴퓨터가 369를 하려면 어떤 방식이 필요할까
2. 숫자를 자리마다 하나씩 쪼개서 보개 만들면 가능할까
3. 쪼개서 그 쪼갠 자릿수가 3,6,9안에 있다면 결과str에 추가하는 방식으로 해보자
4. 문제가 생겼다 ex) 359같은 경우 -5- 이런식으로 추가된다.
5. 다른 방법을 찾아야 한다 자릿수가 3,6,9에 속한 횟수만큼 하이푼을 추가할 수 없을까
6. 이중포문을 이용해보자
7. 첫 번째 for문에선 인덱싱 할 숫자가 나오게하고
8. 두 번째 for문에선 그 숫자의 길이만큼 for문을 돌리며 시도해보자
9. GREAT! GO!

#### 코딩 풀이 👀

```python
N = int(input())

# 3, 6, 9를 담은 str A를 만들고
A ='3', '6', '9'

# 답도 빈 스트링으로 표현
Answer = ''

# 1~input(N)까지를 for문으로 돌리면서
for i in range(1, N+1):
    # i값을 문자화하여 B로 저장 why? 인덱싱을 위해
    B = str(i)
    # 문자화된 해당 i가 3,6,9에 일치한 횟수를 count하기 위한 변수 count
    count = 0
    # 이중 for문으로 B의 길이만큼 돌린다.why? 인덱싱할 길이니깐
    for j in range(len(B)):
        # 만약 B의 인덱싱값이 A (3,6,9) 안에 있다면
        if B[j] in A:
            # count에 1을 더해준다.
            count += 1
     # 만약 count가 한 번도 일어나지 않아 count가 0이라면
    if count == 0:
        # Answer에는 B를 그대로 더해주고
        Answer += B
    else:
        # count가 한 번이라도 일어났다면 '-'를 count수만큼 곱해서 더해준다.
        Answer += '-'*count
      # 사이사이 빈 칸이 필요하므로 Answer에 빈 칸은 밑에 for문이 끝날 때 마다 한 번씩 더해준다.
    Answer += ' '
        
print(Answer)
```

#### 원본 코딩 🤞

```python
N = int(input())

A ='3', '6', '9'

Answer = ''

for i in range(1, N+1):
    B = str(i)
    count = 0
    for j in range(len(B)):
        if B[j] in A:
            count += 1
    if count == 0:
        Answer += B
    else:
        Answer += '-'*count
    Answer += ' '
        
print(Answer)
```



### 2007. 패턴 마디의 길이

> 각 문자열의 길이는 30이다. 마디의 최대 길이는 10이다.
>
> 
> **[입력]**
>
> 가장 첫 줄에는 테스트 케이스의 개수 T가 주어지고, 그 아래로 각 테스트 케이스가 주어진다.
>
> 각 테스트 케이스의 첫 번째 줄에는 길이가 30인 문자열이 주어진다.
>
> 
> **[출력]**
>
> 출력의 각 줄은 '#t'로 시작하고, 공백을 한 칸 둔 다음 정답을 출력한다.
>
> (t는 테스트 케이스의 번호를 의미하며 1부터 시작한다.)
>  
>
> 입력
>
> 3    
> KOREAKOREAKOREAKOREAKOREAKOREA
> SAMSUNGSAMSUNGSAMSUNGSAMSUNGSA
> GALAXYGALAXYGALAXYGALAXYGALAXY   
>
> 출력
>
> #1 5
> \#2 7



#### Think Process ⚡

1. 단어가 같다는 것을 컴퓨터가 어떻게 알 수 있을까
2. 예제를 보니 반복단어는 우선 첫글자부터 시작되는 것 같다.
3. 슬라이싱을 활용하면 될 거 같은데
4. 반복문과 슬라이싱, 0부터의 인덱스를 이용해서 코딩해보자 

#### 코딩 풀이 👀

```python
# test_case 갯수 인풋으로 받고
test_case = int(input())
# 인풋 값만큼 for문 돌리며
for i in range(test_case):
    # input값들을 빈칸 기준으로 나누며 str화하여 list에 담아 변수에 저장
    senten = list(map(str,input().split()))
   # senten for문 돌리며
    for sen in senten:
        # 문자열의 최대 길이가 10이랬으므로 1~10 for문 돌린다
        for j in range(1,11):
# 만약 0~j까지의 인덱싱과 j+1~ 2*(j+1)의 값이 같다면 같은 단어가 연달아 있는 인덱싱범위를 구한 셈
            if senten[0][0:j+1] == senten[0][j+1: 2*(j+1)]:
               # 0부터 인덱싱한 j+1을 출력하면 그 글자의 길이를 구할 수 있다.
                print(f'#{i+1} {j+1}')
               # 답나왔으니 이후 for문은 돌릴 필요 없으므로 break
                break
```

#### 원본 코딩 🤞

```python
test_case = int(input())
for i in range(test_case):
    senten = list(map(str,input().split()))

    for sen in senten:
        for j in range(1,11):


            if senten[0][0:j+1] == senten[0][j+1: 2*(j+1)]:
                print(f'#{i+1} {j+1}')
                break
```

