
### 백준 2669. 직사각형 네개의 합집합의 면적 구하기



평면에 네 개의 직사각형이 놓여 있는데 그 밑변은 모두 가로축에 평행하다. 이 네 개의 직사각형들은 서로 떨어져 있을 수도 있고, 겹쳐 있을 수도 있고, 하나가 다른 하나를 포함할 수도 있으며, 변이나 꼭짓점이 겹칠 수도 있다.

이 직사각형들이 차지하는 면적을 구하는 프로그램을 작성하시오.

![img](8vR77Ew2O2PqvZ1lER716.png)

## 입력

입력은 네 줄이며, 각 줄은 직사각형의 위치를 나타내는 네 개의 정수로 주어진다. 첫 번째와 두 번째의 정수는 사각형의 왼쪽 아래 꼭짓점의 x좌표, y좌표이고 세 번째와 네 번째의 정수는 사각형의 오른쪽 위 꼭짓점의 x좌표, y좌표이다. 모든 x좌표와 y좌표는 1이상이고 100이하인 정수이다.

## 출력

첫 줄에 네개의 직사각형이 차지하는 면적을 출력한다.

## 예제 입력 1 복사

```
1 2 4 4
2 3 5 7
3 1 6 5
7 3 8 6
```

## 예제 출력 1 복사

```
26
```



#### Think Proccss ⚡

1. 빈도화지를 만든다

2. 받은 데이터는 꼭지점 기준이기 때문에 데이터조정을 해준다

3. 각 직사각형들의 인덱스를 빈도화지에 +1씩 한다

4. 도화지에 칠해진 숫자들을 count해서 print해준다

   

#### 코딩풀이 👀

```python
# 우선 100 X 100 배열 도화지를 만들자
coordi = [[0]*100 for _ in range(100)]

# 4번의 반복동안 저 도화지에 색칠하는거여

for _ in range(4):
    x1, y1, x2, y2 = map(int, input().split())

    # 2차배열로 돌리면서 이 직사각형의 좌표를 도화지에 그린다
    # 단 현재 받은 좌표는 꼭짓점 좌표이므로 약간의 조정이 필요하다
    # 내가 편한 데이터로 만들기 위해서 
    # ex) 1 1 1
    #     1 1 1   이런 데이터가 있다하면 1의 갯수를 세고 넓이가 6이라 출력가능
    # x2, y2 데이터를 각각 -1씩 해주면 원하는 데이터로 사용할 수 있다.
    x1, y1, x2, y2 = x1, y1, x2-1, y2-1
    for i in range(x1, x2+1):  # 결국 range에 특성상 +1을 해줘서 그게 그거긴 해졌지만 개념은 다름
        for j in range(y1, y2+1):
            coordi[i][j] += 1

# 도화지 색칠이 다 끝나면
# 칠해진 2차원 도화지를 탐색하며 칠해져있으면 width에 1씩 추가
width = 0
for a in range(len(coordi)):
    for b in range(len(coordi)):
        if coordi[a][b] > 0:
            width += 1

print(width)
```





### 2635 수 이어가기



다음과 같은 규칙에 따라 수들을 만들려고 한다.

1. 첫 번째 수로 양의 정수가 주어진다.
2. 두 번째 수는 양의 정수 중에서 하나를 선택한다.
3. 세 번째부터 이후에 나오는 모든 수는 앞의 앞의 수에서 앞의 수를 빼서 만든다. 예를 들어, 세 번째 수는 첫 번째 수에서 두 번째 수를 뺀 것이고, 네 번째 수는 두 번째 수에서 세 번째 수를 뺀 것이다.
4. 음의 정수가 만들어지면, 이 음의 정수를 버리고 더 이상 수를 만들지 않는다.

첫 번째 수로 100이 주어질 때, 두 번째 수로 60을 선택하여 위의 규칙으로 수들을 만들면 7개의 수들 100, 60, 40, 20, 20 , 0, 20이 만들어진다. 그리고 두 번째 수로 62를 선택하여 위의 규칙으로 수들을 만들면 8개의 수들 100, 62, 38, 24, 14, 10, 4, 6이 만들어진다. 위의 예에서 알 수 있듯이, 첫 번째 수가 같더라도 두 번째 수에 따라서 만들어지는 수들의 개수가 다를 수 있다.

입력으로 첫 번째 수가 주어질 때, 이 수에서 시작하여 위의 규칙으로 만들어지는 최대 개수의 수들을 구하는 프로그램을 작성하시오. 최대 개수의 수들이 여러 개일 때, 그중 하나의 수들만 출력하면 된다.

## 입력

첫 번째 수가 주어진다. 이 수는 30,000 보다 같거나 작은 양의 정수이다.

## 출력

첫 번째 줄에는 입력된 첫 번째 수로 시작하여 위의 규칙에 따라 만들 수 있는 수들의 최대 개수를 출력한다.

둘째 줄에 그 최대 개수의 수들을 차례대로 출력한다. 이들 수 사이에는 빈칸을 하나씩 둔다.

## 예제 입력 1 복사

```
100
```

## 예제 출력 1 복사

```
8
100 62 38 24 14 10 4 6
```



#### Think Proccss ⚡

1. 원래는 후보가 될만한 2번째 수의 범위를 설정하고 시작하려 했지만 변수가 생길 수 있으니 그냥 완전탐색하자!
2. 첫번째, 두번째, 세번째 수가 서로의 변수가 되어 계속 이동해야한다
3. 모든 경우의 수를 구한 후 그 중 가장 count가 많은 경우의 count수와 그에 맞는 수들을 출력하자

#### 코딩풀이 👀

```python
N = int(input())

count = 0 # 가장 큰 수만을 남겨두아 나중에 출력
answer = [] # 우선은 리스트로 answer가 되는 수를 뽑아보자
for second in range(1, N+1): # 처음에 range(N)으로 했다가 N이 1일때 예외사항이 나와서 계속 틀림  
    reserve_count = 0 # 최종 카운트로 가기전 후보군들
    third = N-second # 3번째로 오는 수  
    first = N # 첫번째로 오는 수
    reserve_answer = [first, second, thrid] 
    while thrid >= 0:
        third = second-third
        second = first-second # 다음 회차에 second이기 때문에 f-s 가 가능
        first = second+thrid # 위에 두 계산으로 변화된 second, thrid이기에 가능
        reserve_count += 1  # 한 턴마다 예비 정답에 count와 숫자 추가
        reserve_answer += [j]
    
    if count < reserve_count: # 최대값의 count를 구하며 answer에도 그 값들을 담기 위함
        count = reserve_count
        answer = reserve_answer

answer_ = ''  # 스트링화해서 뽑아야 하므로 answer리스트를 스트링화
for a in range(len(answer)-1):
    answer_ += str(answer[a]) + ' '

print(count+2) # 처음에 1,2,3번째 오는 수를 포함하고 count했기 때문에 +2 해줘야함
print(answer_)
```



---



### 1244 스위치 켜고끄기



1부터 연속적으로 번호가 붙어있는 스위치들이 있다. 스위치는 켜져 있거나 꺼져있는 상태이다. <그림 1>에 스위치 8개의 상태가 표시되어 있다. ‘1’은 스위치가 켜져 있음을, ‘0’은 꺼져 있음을 나타낸다. 그리고 학생 몇 명을 뽑아서, 학생들에게 1 이상이고 스위치 개수 이하인 자연수를 하나씩 나누어주었다. 학생들은 자신의 성별과 받은 수에 따라 아래와 같은 방식으로 스위치를 조작하게 된다.

스위치 번호 ① ② ③ ④ ⑤ ⑥ ⑦ ⑧
스위치 상태  0 1  0 1  0  0  0 1
<그림 1>

남학생은 스위치 번호가 자기가 받은 수의 배수이면, 그 스위치의 상태를 바꾼다. 즉, 스위치가 켜져 있으면 끄고, 꺼져 있으면 켠다. <그림 1>과 같은 상태에서 남학생이 3을 받았다면, 이 학생은 <그림 2>와 같이 3번, 6번 스위치의 상태를 바꾼다.

스위치 번호 ① ② ③ ④ ⑤ ⑥ ⑦ ⑧
스위치 상태  0 1  1 1  0  1  0 1
<그림 2>

여학생은 자기가 받은 수와 같은 번호가 붙은 스위치를 중심으로 좌우가 대칭이면서 가장 많은 스위치를 포함하는 구간을 찾아서, 그 구간에 속한 스위치의 상태를 모두 바꾼다. 이때 구간에 속한 스위치 개수는 항상 홀수가 된다.

예를 들어 <그림 2>에서 여학생이 3을 받았다면, 3번 스위치를 중심으로 2번, 4번 스위치의 상태가 같고 1번, 5번 스위치의 상태가 같으므로, <그림 3>과 같이 1번부터 5번까지 스위치의 상태를 모두 바꾼다. 만약 <그림 2>에서 여학생이 4를 받았다면, 3번, 5번 스위치의 상태가 서로 다르므로 4번 스위치의 상태만 바꾼다.

스위치 번호 ① ② ③ ④ ⑤ ⑥ ⑦ ⑧
스위치 상태  1  0 0  0 1  1  0 1
<그림 3>

입력으로 스위치들의 처음 상태가 주어지고, 각 학생의 성별과 받은 수가 주어진다. 학생들은 입력되는 순서대로 자기의 성별과 받은 수에 따라 스위치의 상태를 바꾸었을 때, 스위치들의 마지막 상태를 출력하는 프로그램을 작성하시오.

## 입력

첫째 줄에는 스위치 개수가 주어진다. 스위치 개수는 100 이하인 양의 정수이다. 둘째 줄에는 각 스위치의 상태가 주어진다. 켜져 있으면 1, 꺼져있으면 0이라고 표시하고 사이에 빈칸이 하나씩 있다. 셋째 줄에는 학생수가 주어진다. 학생수는 100 이하인 양의 정수이다. 넷째 줄부터 마지막 줄까지 한 줄에 한 학생의 성별, 학생이 받은 수가 주어진다. 남학생은 1로, 여학생은 2로 표시하고, 학생이 받은 수는 스위치 개수 이하인 양의 정수이다. 학생의 성별과 받은 수 사이에 빈칸이 하나씩 있다.

## 출력

스위치의 상태를 1번 스위치에서 시작하여 마지막 스위치까지 한 줄에 20개씩 출력한다. 예를 들어 21번 스위치가 있다면 이 스위치의 상태는 둘째 줄 맨 앞에 출력한다. 켜진 스위치는 1, 꺼진 스위치는 0으로 표시하고, 스위치 상태 사이에 빈칸을 하나씩 둔다.

## 예제 입력 1 복사

```
8
0 1 0 1 0 0 0 1
2
1 3
2 3
```

## 예제 출력 1 복사

```
1 0 0 0 1 1 0 1
```



#### Think Proccss ⚡

1. 남자 여자 나눠서 생각하자
2. 남자는 배수처리니깐 나머지를 이용하고
3. 여자는 while문과 인덱스를 이용해서 처리해보자

```python
X = int(input())

switch = list(map(int, input().split()))

for tc in range(1, int(input())+1):
    S, N = map(int, input().split())

    if S == 1:  # 만약 성별이 남자라면
        for i in range(1, len(switch)+1): # for문을 돌리면서 스위치 번호가 1~N이니 1부터 세주고
            if i % N == 0: # i가 N의 배수라면
                if switch[i-1] == 0: # 인덱싱으론 i-1 해주고 1 이면 0으로, 0이면 1로 바꿔준다
                    switch[i-1] = 1
                else:
                    switch[i-1] = 0

    else: # 여자라면
        N -= 1 # 받을 N을 우리가 편한 인덱스로 바꿔주고
        start = N - 1  # 비교 시작점
        end = N + 1  # 비교 끝점
        stop = 0 # while문 끝내는 트리거
        while start >= 0 and end <= X and stop == 0:
            start -= 1 # 한칸 왼쪽으로 일단 가고!
            end += 1 # 한칸 오른쪽으로
            if switch[start] != switch[end] or start <= 0 or end > X:  # 틀리거나 벗어나면
                stop = 1  # 스탑!
            else: # 맞으면
                stop = 0 # 진행
        # start점과 end점을 알았으니 이것을 for문으로 돌리며 바꿔주면됨

        for x in range(start, end+1):
            if switch[x] == 0:
                switch[x] = 1
            else:
                switch[x] = 0

# 마지막에 문제에 맞게 스트링화

switch_ = ''
for i in range(X):
    switch_ += str(switch[i])
    switch_ += ' '

print(switch_)

# 출력 스타일에 맞추기가 실패한건가
# 20줄씩 끊어서 출력하라는데 어떻게 하는거지
```



---



### 2304 창고 다각형

N 개의 막대 기둥이 일렬로 세워져 있다. 기둥들의 폭은 모두 1 m이며 높이는 다를 수 있다. 이 기둥들을 이용하여 양철로 된 창고를 제작하려고 한다. 창고에는 모든 기둥이 들어간다. 이 창고의 지붕을 다음과 같이 만든다.

1. 지붕은 수평 부분과 수직 부분으로 구성되며, 모두 연결되어야 한다.
2. 지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다.
3. 지붕의 수직 부분은 반드시 어떤 기둥의 옆면과 닿아야 한다.
4. 지붕의 가장자리는 땅에 닿아야 한다.
5. 비가 올 때 물이 고이지 않도록 지붕의 어떤 부분도 오목하게 들어간 부분이 없어야 한다.

그림 1은 창고를 옆에서 본 모습을 그린 것이다. 이 그림에서 굵은 선으로 표시된 부분이 지붕에 해당되고, 지붕과 땅으로 둘러싸인 다각형이 창고를 옆에서 본 모습이다. 이 다각형을 창고 다각형이라고 하자.

![img](cd.png)
그림1 . 기둥과 지붕(굵은 선)의 예

창고 주인은 창고 다각형의 면적이 가장 작은 창고를 만들기를 원한다. 그림 1에서 창고 다각형의 면적은 98 ㎡이고, 이 경우가 가장 작은 창고 다각형이다.

기둥들의 위치와 높이가 주어질 때, 가장 작은 창고 다각형의 면적을 구하는 프로그램을 작성하시오.

## 입력

첫 줄에는 기둥의 개수를 나타내는 정수 N이 주어진다. N은 1 이상 1,000 이하이다. 그 다음 N 개의 줄에는 각 줄에 각 기둥의 왼쪽 면의 위치를 나타내는 정수 L과 높이를 나타내는 정수 H가 한 개의 빈 칸을 사이에 두고 주어진다. L과 H는 둘 다 1 이상 1,000 이하이다.

## 출력

첫 줄에 창고 다각형의 면적을 나타내는 정수를 출력한다.

## 예제 입력 1 복사

```
7
2 4
11 4
15 8
4 6
5 3
8 10
13 6
```

## 예제 출력 1 복사

```
98
```



#### Think Proccss ⚡

1. 우선 인풋이 정렬되어 있지 않으니 가로 인덱스를 기준으로 인덱스와 높이를 정렬시키자
2. 높이중에 가장 높은 놈을 기준으로 왼쪽부터 계단형식, 오른쪽부터 계단 형식으로 높이리스트를 조절하자
3. 위치인덱스 정렬 리스트와, 높이 정렬 리스트을 활용하여 면적을 구하자



```python
# 우선 1000 X 1000 배열 도화지를 만들자
coordi = [[0] * 1000 for _ in range(1000)]
# 굳이 따지면 문제의 그림을 거꾸로 매달아 보는 셈인데 이 coordi는  H값을 옳바르게 정렬시키는데 사용된다

N = int(input())  # 기둥의 갯수
L_list = []  # L의 list
for _ in range(N):
    L, H = map(int, input().split())  # L과 H가 L기준 왼쪽부터 순서대로 나오는게 아니라 랜덤하게 입력된다..
    L_list.append(L)  # 우선 L은 리스트로 만들어주고
    # L을 왼쪽면에 위치라고 생각하지말고 코딩상에서 그 기둥의 인덱스라고 생각하자
    H -= 1
    # 그리고 H는 -1 해주자 why? 예를 들어 L=2, H=4 라면
    # 0,0 부터 시작하는 1000X1000 도화지에서는 0,2 1,2 2,2 3,2 4,2로 면적이 5라 측정되기 때문이다
    for i in range(H + 1):  # 레인지니깐 +1
        coordi[i][L] = 1  # 도화지에 색칠 / L은 고정시키고 H만 움직인다

# 색칠한 도화지를 이용해서 입력받은 L, H값을 L이 작은수부터 정렬되게 만들고 그와 짝인 H값도 순서대로 만들어줘야 한다.
L_list.sort()  # L_list는 sort로 작은수부터 해서 정렬

H_list = [0] * N  # H의 리스트

A = 0  # H_list에 인덱스
B = 0  # 열 검색할때 시작점
k = 0  # 각 기둥의 높이 표현
# 시작이 -1인 이유: 현재 색칠된 도화지를 돌며 k를 탐색할껀데 k=0부터 시작하면
# 0부터 센 높이의 값이 아니라 실제 높이가 나오기 때문
while A < N:  # 열검색, A가 H_list 보다 작은 동안 ( 밑에서 기둥이 발견되면 +1 씩 해줄거임 )
    for i in range(B, 1000):  # 기둥이 발견되면 그 뒤부터 검색해야하니 범위를 B로 설정 우선은 0
        k = 0  # 기둥이 발견되도 다시 돌릴 때는 초기화 해야 하므로 k = 0
        for j in range(1000):
            if coordi[j][i] == 1:  # 만약 1000 X 1000 도화지에서 coordi[1][0], [2][0], [3][0] 이렇게 돌다가 1이 발견되면
                k += 1  # k는 층수의 높이므로 +1을 해준다
        # 세로줄 한줄의 탐색이 끝났을때
        if k > 0:  # 만약 k가 발견되어 있으면
            H_list[A] = k  # H_list에 추가해주고
            A += 1  # A는 다음 인덱스를 찾아야하니 +1 해주고
            B = i + 1  # B 역시 이 다음 열부터 찾아야 하니 i+1로 입력해준다
            break

# 내가 원하는 답은 test_case라고 했을 때  // L = [2, 4, 5, 8, 11, 13, 15], H = [4, 6, 3, 10, 4, 6, 8]  잘나옴!
# 여기 까지 1000 X 1000 0의 도화지에 L,H에 맞춰서 1로 색칠했고 L,H를 리스트로 따로 빼뒀음

# 가장 큰 놈을 기준으로 왼쪽부터 for문 돌리고 오른쪽부터 역으로 for문을 돌리자
max_idx = 0  # 가장 큰 놈의 인덱스 구하기
max_number = 0

for i in range(len(H_list)):
    if max_number < H_list[i]:
        max_number = H_list[i]
        max_idx = i

# 가장 큰 놈의 인덱스를 기준으로 ( 가장 큰 놈이 여러개여도 상관 없음)
# 왼쪽부터 정렬시키고
for i in range(max_idx):
    if H_list[i] >= H_list[i + 1]:  # 만약 나보다 오른쪽 놈이 나보다 작거나 같으면
        H_list[i + 1] = H_list[i]  # 그 놈을 나랑 똑같게 만든다

# 오른쪽도 정렬
for i in range(len(H_list) - 1, max_idx, -1):
    if H_list[i] >= H_list[i - 1]:  # 만약 나보다 왼쪽 놈이 나보다 작거나 같으면
        H_list[i - 1] = H_list[i]  # 그 놈을 나랑 똑같게 만든다

# 여기까지 test_case로 치면 L = [2, 4, 5, 8, 11, 13, 15] H = [4, 6, 6, 10, 8, 8, 8] 까지 완성시켰다

# 이제 이 두 리스트를 이용하여 면적값만 구하면 된다

# 마찬가지로 제일 높은 층수의 max_idx를 기준으로 삼고
# 0~ max_idx까지
total = 0
for i in range(max_idx):
    total += (L_list[i+1]-L_list[i]) * H_list[i]  # 인접한 L의 차 X 그에 맞는 H를 total에 더해주는 것이다.

# 뒤에서 ~ max_idx까지
for i in range(len(H_list)-1, max_idx, -1):
    total += (L_list[i]-L_list[i-1]) * H_list[i]

# 마지막으로 기준이 되는 max_idx 값 total에 추가
total += H_list[max_idx]

print(total)

# 테스트 케이스는 맞게 나오는데 패스가 안됨 뭐고!!!!!!!!!!!!!!!!!!!!!!!!
```

